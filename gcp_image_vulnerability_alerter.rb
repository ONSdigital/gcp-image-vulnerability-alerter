#!/usr/bin/env ruby
# frozen_string_literal: true

require 'date'
require 'google/cloud/container_analysis'
require 'google/cloud/firestore'
require 'logger'
require 'rest-client'
require 'time'

require_relative 'lib/core_ext/object'
require_relative 'package_issue'

# Class that posts alerts to a specified Slack channel when Docker images with high or critical security vulnerabilities
# as identified by the Google Container Analysis API are found in the formal GCR repositories.
class GCPContainerAnalysis
  DATE_TIME_FORMAT     = '%A %d %b %Y %H:%M:%S UTC'
  FIRESTORE_COLLECTION = 'gcp-image-vulnerability-alerter'
  SEVERITIES           = %i[HIGH CRITICAL].freeze
  ONE_SECOND           = 1
  THREE_SECONDS        = 3

  Vulnerability = Struct.new(:resource_uri, :package_issues)

  def initialize
    environment_check
    initialize_firestore_client
    @logger = Logger.new($stdout)
    @client = Google::Cloud::ContainerAnalysis.new
  end

  def run
    todays_vulnerability_occurrences.each do |occurrence|
      package_issues = []
      effective_severity = occurrence.vulnerability.effective_severity
      next unless SEVERITIES.include?(effective_severity)

      occurrence.vulnerability.package_issue.each do |issue|
        short_description = occurrence.vulnerability.short_description
        next if short_description.blank?

        package_issues << PackageIssue.new(effective_severity, short_description, issue.affected_package)
      end
      occurrence.vulnerability.related_urls.each do |related_url|
        package_issues.each { |package_issue| package_issue.related_url = related_url.url }
      end

      next if package_issues.empty?

      vulnerability = Vulnerability.new(occurrence.resource_uri, package_issues)
      post_slack_message(vulnerability) unless in_firestore?(vulnerability)
      save_to_firestore(vulnerability)
    end
  end

  private

  def environment_check
    raise 'Missing CONTAINER_ANALYSIS_CREDENTIALS environment variable' unless ENV['CONTAINER_ANALYSIS_CREDENTIALS']
    raise 'Missing CONTAINER_ANALYSIS_PROJECT environment variable' unless ENV['CONTAINER_ANALYSIS_PROJECT']
    raise 'Missing FIRESTORE_PROJECT environment variable' unless ENV['FIRESTORE_PROJECT']
    raise 'Missing GCP_VULNERABILITY_ALERTER_SLACK_CHANNEL environment variable' unless ENV['GCP_VULNERABILITY_ALERTER_SLACK_CHANNEL']
    raise 'Missing SLACK_WEBHOOK environment variable' unless ENV['SLACK_WEBHOOK']
  end

  def image_id_from_resource_uri(resource_uri)
    resource_uri.partition('sha256:').last
  end

  def in_firestore?(vulnerability)
    image_id = image_id_from_resource_uri(vulnerability.resource_uri)
    doc = @firestore_client.doc "#{FIRESTORE_COLLECTION}/#{image_id}"
    snapshot = doc.get
    if snapshot.data.nil?
      @logger.debug("Image #{image_id} has no snapshot data in Firestore")
      return false
    end

    @logger.debug("Snapshot project in Firestore is #{snapshot[:project]}, CONTAINER_ANALYSIS_PROJECT is #{ENV['CONTAINER_ANALYSIS_PROJECT']}")
    snapshot[:project].eql?(ENV['CONTAINER_ANALYSIS_PROJECT'])
  end

  def initialize_firestore_client
    Google::Cloud::Firestore.configure do |config|
      config.project_id  = ENV['FIRESTORE_PROJECT']
      config.credentials = ENV['CONTAINER_ANALYSIS_CREDENTIALS']
    end

    @firestore_client = Google::Cloud::Firestore.new
  end

  # See https://stackoverflow.com/a/42001209
  def occurrence_time_to_time(occurrence)
    epoch_ms = occurrence.create_time.nanos / 10**6
    Time.at(occurrence.create_time.seconds, epoch_ms)
  end

  def post_slack_message(vulnerability)
    sleep THREE_SECONDS # Avoid Slack's rate limits.
    attachments = []
    vulnerability.package_issues.each { |package_issue| attachments << package_issue.to_slack_attachment }
    vulnerability_noun = vulnerability.package_issues.length > 1 ? 'Vulnerabilities' : 'Vulnerability'
    payload = {
      'channel': ENV['GCP_VULNERABILITY_ALERTER_SLACK_CHANNEL'],
      'icon_emoji': ':gcp:',
      'username': "#{ENV['CONTAINER_ANALYSIS_PROJECT']} - GCP Image Vulnerability Alerter",
      'text': "#{vulnerability_noun} found in image #{vulnerability.resource_uri}:",
      'attachments': attachments
    }.to_json.encode('UTF-8')
    headers = { 'Content-Type': 'application/json' }
    begin
      RestClient.post(ENV['SLACK_WEBHOOK'].chomp, payload, headers)
    rescue RestClient::ExceptionWithResponse => e
      @logger.error("Error posting to Slack: HTTP #{e.response.code} #{e.response}")
    end
  end

  def save_to_firestore(vulnerability)
    image_id = image_id_from_resource_uri(vulnerability.resource_uri)
    @logger.info("Saving #{image_id} to Firestore")
    sleep ONE_SECOND # Avoid Firestore's rate limits.
    doc = @firestore_client.doc("#{FIRESTORE_COLLECTION}/#{image_id}")
    doc.set(timestamp: DateTime.now.rfc3339, project: ENV['CONTAINER_ANALYSIS_PROJECT'])
  end

  def today?(day)
    day >= Time.now.day
  end

  def todays_vulnerability_occurrences
    grafeas_client = @client.grafeas_client
    parent = Grafeas::V1::GrafeasClient.project_path(ENV['CONTAINER_ANALYSIS_PROJECT'])
    occurrences = []
    grafeas_client.list_occurrences(parent).each do |occurrence|
      occurrence_time = occurrence_time_to_time(occurrence)
      occurrences << occurrence if today?(occurrence_time.day) && occurrence.kind == :VULNERABILITY
    end
    @logger.debug("#{occurrences.length} vulnerability occurrences in scope for #{ENV['CONTAINER_ANALYSIS_PROJECT']} today")
    occurrences
  end
end

GCPContainerAnalysis.new.run
